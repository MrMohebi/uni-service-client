# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

directive @response on FIELD_DEFINITION

directive @userAuth(token: String) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @userIdAuth(token: String) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

type Appeal {
    attachments: [UploadedFile]
    categoryID: String
    connectWay: String
    createdAt: Int
    details: String
    hashtagIDs: [ID]
    hashtags: [String]
    id: ID
    link: String
    modifiedContentAt: Int
    priceEnd: Int
    priceStart: Int
    publishedAt: Int
    seen: Int
    tagLink: String
    title: String
    universityID: String
    verifiedAt: Int
    verifierID: String
}

"A paginated list of Appeal edges."
type AppealConnection {
    "A list of Appeal edges."
    edges: [AppealEdge!]!
    "Pagination information about the list of edges."
    pageInfo: PageInfo!
}

"An edge that contains a node of type Appeal and a cursor."
type AppealEdge {
    "A unique cursor that can be used for pagination."
    cursor: String!
    "The Appeal node."
    node: Appeal!
}

type CreatePayment {
    url: String
}

type Login {
    deviceToken: String
    id: ID!
    name: String
    phone: String!
    token: String!
    username: String
}

type Mutation {
    addSubscriber(age: String, email: String, name: String, phone: String): Int
    appealConnectClick(appealID: ID!, userID: ID): Response_appealConnectClick_wpls
    chargeWallet(amount: Int!, walletID: String!): Response_chargeWallet_hqqi
    createAppeal(categoryID: String, connectWay: String!, details: String, files: [UploadedFileInput], hashtags: [String], priceEnd: Int!, priceStart: Int!, title: String!): Response_createAppeal_fmkv
    seen(list: [Seen], type: String!): Response_seen_uogb
    sendVCode(phone: String!, userAgent: String): Response_sendVCode_cugz
    updateUser(bio: String, birthAt: Int, email: String, hasAppealsHistory: Boolean, hasAskHistory: Boolean, hasBookHistory: Boolean, hasLastSeen: Boolean, lastname: String, name: String, universityID: ID, username: String): Response_updateUser_velh
    uploadPublicFileAccess(appealID: String, bookID: String, fileMime: String!, fileName: String!, filePath: String!, fileType: String!, previewPath: String, thumbnailPath: String, type: String!, uploadedAsFile: Boolean): Response_uploadPublicFileAccess_hyqc
    verifyAppeal(adminToken: String!, id: ID!, status: String!): Boolean
    verifyVCode(phone: String!, referenceCode: String, vCode: String!): Response_verifyVCode_cccp
}

type Notification {
    appeal: Appeal
    created_at: String
    id: ID
    sender: User
    type: String!
    user: User
}

"A paginated list of Notification edges."
type NotificationConnection {
    "A list of Notification edges."
    edges: [NotificationEdge!]!
    "Pagination information about the list of edges."
    pageInfo: PageInfo!
}

"An edge that contains a node of type Notification and a cursor."
type NotificationEdge {
    "A unique cursor that can be used for pagination."
    cursor: String!
    "The Notification node."
    node: Notification!
}

"Information about pagination using a Relay style cursor connection."
type PageInfo {
    "Number of nodes in the current page."
    count: Int!
    "Index of the current page."
    currentPage: Int!
    "The cursor to continue paginating forwards."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Index of the last available page."
    lastPage: Int!
    "The cursor to continue paginating backwards."
    startCursor: String
    "Total number of nodes in the paginated connection."
    total: Int!
}

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
    "Number of items in the current page."
    count: Int!
    "Index of the current page."
    currentPage: Int!
    "Index of the first item in the current page."
    firstItem: Int
    "Are there more pages after this one?"
    hasMorePages: Boolean!
    "Index of the last item in the current page."
    lastItem: Int
    "Index of the last available page."
    lastPage: Int!
    "Number of items per page."
    perPage: Int!
    "Number of total available items."
    total: Int!
}

type Query {
    appeal(id: ID!): Appeal
    appeals(
        "A cursor after which elements are returned."
        after: String,
        "Limits number of fetched items. Maximum allowed value: 100."
        first: Int = 20,
        searchText: String
    ): AppealConnection
    isReferenceCodeValid(referenceCode: String): Response_isReferenceCodeValid_zwre
    notifications(
        "A cursor after which elements are returned."
        after: String,
        "Limits number of fetched items. Maximum allowed value: 100."
        first: Int = 20
    ): NotificationConnection
    test(x: String): Response_test_pecu
    user: Response_user_ifes
    wallet: Response_wallet_egej
}

type Response_appealConnectClick_wpls {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_chargeWallet_hqqi {
    data: CreatePayment
    errors: String
    message: String
    status: Status!
}

type Response_createAppeal_fmkv {
    data: Appeal
    errors: String
    message: String
    status: Status!
}

type Response_isReferenceCodeValid_zwre {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_seen_uogb {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_sendVCode_cugz {
    data: VCode
    errors: String
    message: String
    status: Status!
}

type Response_test_pecu {
    data: TTT
    errors: String
    message: String
    status: Status!
}

type Response_updateUser_velh {
    data: User
    errors: String
    message: String
    status: Status!
}

type Response_uploadPublicFileAccess_hyqc {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_user_ifes {
    data: User
    errors: String
    message: String
    status: Status!
}

type Response_verifyVCode_cccp {
    data: Login
    errors: String
    message: String
    status: Status!
}

type Response_wallet_egej {
    data: Wallet
    errors: String
    message: String
    status: Status!
}

"Information about pagination using a simple paginator."
type SimplePaginatorInfo {
    "Number of items in the current page."
    count: Int!
    "Index of the current page."
    currentPage: Int!
    "Index of the first item in the current page."
    firstItem: Int
    "Are there more pages after this one?"
    hasMorePages: Boolean!
    "Index of the last item in the current page."
    lastItem: Int
    "Number of items per page."
    perPage: Int!
}

type TTT {
    tf1: String!
    tf2: String
    tf3: String
}

type UploadedFile {
    mime: String!
    preview: String
    thumbnail: String
    type: String!
    uploadedAsFile: Boolean
    url: String!
}

type User {
    bannerID: ID
    bio: String
    birthAt: Int
    code: String
    created_at: String
    email: String
    expertiseIDs: [ID]
    friendIDs: [ID]
    hasAppealsHistory: Boolean
    hasAskHistory: Boolean
    hasBookHistory: Boolean
    hasLastSeen: Boolean
    id: ID!
    introducerID: ID
    isEmailActivated: Boolean
    isPhoneActivated: Boolean
    lastname: String
    level: Int
    link: String
    linkTag: String
    name: String
    phone: String
    profileIDs: [ID]
    referenceCode: String
    referenceCodeLeft: Int
    savedAppealsIDs: [ID]
    savedAskIDs: [ID]
    savedBookIDs: [ID]
    universityID: ID
    username: String
    verifiedAt: Int
    wallet: Wallet
    xp: Int
    xpLevelPercentage: Int
}

type VCode {
    firstCharacter: String
    hint: String
    isSignup: Boolean
    length: Int!
    phone: String!
    vCode: String!
}

type Wallet {
    balance: Int!
    blocked: Int!
    coins: Int
    totalWithdraw: Int
    userID: ID!
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
    "Amount of items."
    COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
    "Average."
    AVG
    "Amount of items."
    COUNT
    "Maximum."
    MAX
    "Minimum."
    MIN
    "Sum."
    SUM
}

"Directions for ordering a list of records."
enum SortOrder {
    "Sort records in ascending order."
    ASC
    "Sort records in descending order."
    DESC
}

enum Status {
    ERROR
    NOT_AUTH
    NOT_FOUND
    SUCCESS
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
    "Only return trashed results."
    ONLY
    "Return both trashed and non-trashed results."
    WITH
    "Only return non-trashed results."
    WITHOUT
}

"Allows ordering a list of records."
input OrderByClause {
    "The column that is used for ordering."
    column: String!
    "The direction that is used for ordering."
    order: SortOrder!
}

input Seen {
    id: ID!
    times: Int!
    type: String
}

input UploadedFileInput {
    mime: String!
    preview: String
    thumbnail: String
    type: String!
    uploadedAsFile: Boolean
    url: String!
}
