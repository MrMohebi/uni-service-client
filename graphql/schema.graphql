# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

directive @response on FIELD_DEFINITION

directive @userAuth(token: String) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @userIdAuth(token: String) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

type Ad {
    categoryID: String
    completedAt: Int
    createdAt: Int
    creator: User
    deletedAt: Int
    details: String
    doerID: String
    fileIDs: [ID]
    hashtagIDs: [ID]
    hashtags: [String]
    id: ID
    link: String
    modifiedContentAt: Int
    photoIDs: [ID]
    priceEnd: Int
    priceStart: Int
    publishedAt: Int
    seen: Int
    tagLink: String
    title: String
    universityID: String
    verifiedAt: Int
    verifierID: String
    voiceIDs: [ID]
}

"A paginated list of Ad edges."
type AdConnection {
    "A list of Ad edges."
    edges: [AdEdge!]!
    "Pagination information about the list of edges."
    pageInfo: PageInfo!
}

"An edge that contains a node of type Ad and a cursor."
type AdEdge {
    "A unique cursor that can be used for pagination."
    cursor: String!
    "The Ad node."
    node: Ad!
}

type CreatePayment {
    url: String
}

type Login {
    deviceToken: String
    id: ID!
    name: String
    phone: String!
    token: String!
    username: String
}

type Mutation {
    addSubscriber(age: String, email: String, name: String, phone: String): Int
    chargeWallet(amount: Int!, walletID: String!): Response_chargeWallet_twyj
    createAd(categoryID: String, details: String, hashtags: [String], priceEnd: Int!, priceStart: Int!, title: String!): Response_createAd_ptvg
    seen(list: [Seen], type: String!): Response_seen_oxjv
    sendVCode(phone: String!, userAgent: String): Response_sendVCode_xkmx
    updateUser(bio: String, birthAt: Int, email: String, hasAdsHistory: Boolean, hasAskHistory: Boolean, hasBookHistory: Boolean, hasLastSeen: Boolean, lastname: String, name: String, universityID: ID, username: String): Response_updateUser_psht
    uploadPublicFileAccess(adID: String, bookID: String, fileMime: String!, fileName: String!, filePath: String!, type: String!): Response_uploadPublicFileAccess_qlii
    verifyVCode(phone: String!, referenceCode: String, vCode: String!): Response_verifyVCode_zxlm
}

"Information about pagination using a Relay style cursor connection."
type PageInfo {
    "Number of nodes in the current page."
    count: Int!
    "Index of the current page."
    currentPage: Int!
    "The cursor to continue paginating forwards."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Index of the last available page."
    lastPage: Int!
    "The cursor to continue paginating backwards."
    startCursor: String
    "Total number of nodes in the paginated connection."
    total: Int!
}

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
    "Number of items in the current page."
    count: Int!
    "Index of the current page."
    currentPage: Int!
    "Index of the first item in the current page."
    firstItem: Int
    "Are there more pages after this one?"
    hasMorePages: Boolean!
    "Index of the last item in the current page."
    lastItem: Int
    "Index of the last available page."
    lastPage: Int!
    "Number of items per page."
    perPage: Int!
    "Number of total available items."
    total: Int!
}

type Query {
    ad(id: ID!): Ad
    ads(
        "A cursor after which elements are returned."
        after: String,
        "Limits number of fetched items. Maximum allowed value: 100."
        first: Int = 20,
        searchText: String
    ): AdConnection
    isReferenceCodeValid(referenceCode: String): Response_isReferenceCodeValid_egss
    test(x: String): Response_test_dtmz
    user: Response_user_rfjx
    wallet: Response_wallet_qrcd
}

type Response_chargeWallet_twyj {
    data: CreatePayment
    errors: String
    message: String
    status: Status!
}

type Response_createAd_ptvg {
    data: Ad
    errors: String
    message: String
    status: Status!
}

type Response_isReferenceCodeValid_egss {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_seen_oxjv {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_sendVCode_xkmx {
    data: VCode
    errors: String
    message: String
    status: Status!
}

type Response_test_dtmz {
    data: TTT
    errors: String
    message: String
    status: Status!
}

type Response_updateUser_psht {
    data: User
    errors: String
    message: String
    status: Status!
}

type Response_uploadPublicFileAccess_qlii {
    data: Boolean
    errors: String
    message: String
    status: Status!
}

type Response_user_rfjx {
    data: User
    errors: String
    message: String
    status: Status!
}

type Response_verifyVCode_zxlm {
    data: Login
    errors: String
    message: String
    status: Status!
}

type Response_wallet_qrcd {
    data: Wallet
    errors: String
    message: String
    status: Status!
}

"Information about pagination using a simple paginator."
type SimplePaginatorInfo {
    "Number of items in the current page."
    count: Int!
    "Index of the current page."
    currentPage: Int!
    "Index of the first item in the current page."
    firstItem: Int
    "Are there more pages after this one?"
    hasMorePages: Boolean!
    "Index of the last item in the current page."
    lastItem: Int
    "Number of items per page."
    perPage: Int!
}

type TTT {
    tf1: String!
    tf2: String
    tf3: String
}

type User {
    bannerID: ID
    bio: String
    birthAt: Int
    code: String
    email: String
    expertiseIDs: [ID]
    friendIDs: [ID]
    hasAdsHistory: Boolean
    hasAskHistory: Boolean
    hasBookHistory: Boolean
    hasLastSeen: Boolean
    id: ID!
    introducerID: ID
    isEmailActivated: Boolean
    isPhoneActivated: Boolean
    lastname: String
    link: String
    linkTag: String
    name: String
    phone: String
    profileIDs: [ID]
    referenceCode: String
    referenceCodeLeft: Int
    savedAdsIDs: [ID]
    savedAskIDs: [ID]
    savedBookIDs: [ID]
    universityID: ID
    username: String
    verifiedAt: Int
    wallet: Wallet
}

type VCode {
    firstCharacter: String
    hint: String
    isSignup: Boolean
    length: Int!
    phone: String!
    vCode: String!
}

type Wallet {
    balance: Int!
    blocked: Int!
    coins: Int
    totalWithdraw: Int
    userID: ID!
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
    "Amount of items."
    COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
    "Average."
    AVG
    "Amount of items."
    COUNT
    "Maximum."
    MAX
    "Minimum."
    MIN
    "Sum."
    SUM
}

"Directions for ordering a list of records."
enum SortOrder {
    "Sort records in ascending order."
    ASC
    "Sort records in descending order."
    DESC
}

enum Status {
    ERROR
    NOT_AUTH
    NOT_FOUND
    SUCCESS
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
    "Only return trashed results."
    ONLY
    "Return both trashed and non-trashed results."
    WITH
    "Only return non-trashed results."
    WITHOUT
}

"Allows ordering a list of records."
input OrderByClause {
    "The column that is used for ordering."
    column: String!
    "The direction that is used for ordering."
    order: SortOrder!
}

input Seen {
    id: ID!
    times: Int!
    type: String
}
